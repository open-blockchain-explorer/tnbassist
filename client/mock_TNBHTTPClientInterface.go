//go:build mock
// +build mock

package client

import (
	"github.com/open-blockchain-explorer/tnbassist/model"
	"github.com/open-blockchain-explorer/tnbassist/testdata"
	mock "github.com/stretchr/testify/mock"
)

// NewTNBHTTPClient instantiates new TNBHTTPClientInterface compatible client
func NewTNBHTTPClient(httpConfig HTTPConfig) TNBHTTPClientInterface {
	mockClient := MockTNBHTTPClientInterface{}
	mockClient.On("FetchAccountsWithLimitAndOffset", mock.Anything, mock.Anything).Return(nil, nil)
	mockClient.On("FetchAllAccounts", mock.Anything).Return(&testdata.FakeAccounts, nil)
	return &mockClient
}

// MockTNBHTTPClientInterface is an autogenerated mock type for the TNBHTTPClientInterface type
type MockTNBHTTPClientInterface struct {
	mock.Mock
}

// FetchAccountsWithLimitAndOffset provides a mock function with given fields: limit, offset
func (_m *MockTNBHTTPClientInterface) FetchAccountsWithLimitAndOffset(limit uint8, offset uint) (*model.PaginatedAccounts, error) {
	ret := _m.Called(limit, offset)

	var r0 *model.PaginatedAccounts
	if rf, ok := ret.Get(0).(func(uint8, uint) *model.PaginatedAccounts); ok {
		r0 = rf(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.PaginatedAccounts)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint8, uint) error); ok {
		r1 = rf(limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchAllAccounts provides a mock function with given fields:
func (_m *MockTNBHTTPClientInterface) FetchAllAccounts() (*model.Accounts, error) {
	ret := _m.Called()

	var r0 *model.Accounts
	if rf, ok := ret.Get(0).(func() *model.Accounts); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Accounts)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
